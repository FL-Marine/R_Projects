```{r}
library(nycflights13)
library(dplyr)
library(ggplot2)
```

# Exploring data types

Similar to SQL checking data type, do this first before starting anything in R

glimpse - looks at data types
() - whatever is in parentheses is the dataset/database being called

get sample of data and 5-8 values per column

int = integer
dbl = number of more precision for decimals
char = characters
dttm = datetime

Help file brings up info about the dataframe
```{r}
?flights
```

Help to understand a function
```{r}
?left_join
```


```{r}
glimpse(flights)
```
## Scatterplots

Looking at data types for flights
```{r}
glimpse(flights)
```

Looking at dataset
```{r}
View(flights)
```

everything to the right of the arrow is going to alaska_flights as the new variable/dataframe
 %>% passing flights dataset to filter function
```{r}
alaska_flights <- flights %>% 
  filter(carrier == "AS")
```

Looking at alaska_flights data type
```{r}
glimpse(alaska_flights)
```

looking at new alaska_flights dataset
```{r}
View(alaska_flights)
```

Scatterplots normal 
```{r}
ggplot(data = alaska_flights, mapping = aes(x = dep_delay, y = arr_delay)) + geom_point()
```
Within the ggplot() function, we specify two of the components of the grammar of graphics as arguments (i.e., inputs):

1. The data as the alaska_flights data frame via data = alaska_flights.

2. The aesthetic mapping by setting mapping = aes(x = dep_delay, y = arr_delay). Specifically, the variable dep_delay maps to the x position aesthetic, while the variable arr_delay maps to the y position.

We then add a layer to the ggplot() function call using the + sign. The added layer in question specifies the third component of the grammar: the geometric object. In this case, the geometric object is set to be points by specifying geom_point(). After running these two lines of code in your console, you’ll notice two outputs: a warning message and the graphic shown in Figure 2.2.

Overplotting Scatterplots - Method 1- changing transparency
```{r}
ggplot(data = alaska_flights, mapping = aes(x = dep_delay, y = arr_delay)) +
  geom_point(alpha = 0.2)
```

Overplotting Scatterplots - Method 2- Jittering the points
```{r}
ggplot(data = alaska_flights, mapping = aes(x = dep_delay, y = arr_delay)) +
  geom_jitter(width = 30, height = 30)
```

## Linegraphs

Weather data types
```{r}
glimpse(weather)
```

Viewing Weather dataset
Ensure V is always capitalized
```{r}
View(weather)
```

Help file brings up info about the dataframe
```{r}
?weather
```

Creating early_january_weather dataframe
ctrl + shift + m creates pipe %>% 
```{r}
early_january_weather <- weather %>% 
  filter(origin == "EWR" & month == 1 & day <= 15)
```

Viewing early_january_weather dataset
```{r}
View(early_january_weather)
```

Creating linegraphs saved in early_january_weather data frame by using geom_line()
```{r}
ggplot(data = early_january_weather,
       mapping = aes(x = time_hour, y = temp)) +
  geom_line()
```
Within the ggplot() function call, we specify two of the components of the grammar of graphics as arguments:

1. The data to be the early_january_weather data frame by setting data = early_january_weather.

2. The aesthetic mapping by setting mapping = aes(x = time_hour, y = temp). Specifically, the variable time_hour maps to the x position aesthetic, while the variable temp maps to the y position aesthetic.

We add a layer to the ggplot() function call using the + sign. The layer in question specifies the third component of the grammar: the geometric object in question. In this case, the geometric object is a line set by specifying geom_line().

# Histograms

Unlike with scatterplots and linegraphs, there is **now only one variable being mapped in aes(): the single numerical variable temp.** The y-aesthetic of a histogram, the count of the observations in each bin, gets computed for you automatically.

```{r}
ggplot(data = weather, mapping = aes(x = temp)) +
  geom_histogram()
```

geom_histogram(color = "white") adds vertical white borders separating the bins
ignore the warning about setting the number of bins to a better value
```{r}
ggplot(data = weather, mapping = aes(x = temp)) +
  geom_histogram(color = "white")
```

Vary the color of the bars by setting the fill argument. For example, you can set the bin colors to be “blue steel” by setting fill = "steelblue"

```{r}
ggplot(data = weather, mapping = aes(x = temp)) +
  geom_histogram(color = "white", fill = "steelblue")
```
To see all possible color choices run the below code
```{r}
colors()
```

Adjusting the bins
1. By adjusting the number of bins via the bins argument to geom_histogram().

2. By adjusting the width of the bins via the binwidth argument to geom_histogram().

Option 1
Using the first method, we have the power to specify how many bins we would like to cut the x-axis up in. As mentioned in the previous section, the default number of bins is 30. We can override this default, to say 40 bins, as follows:
```{r}
ggplot(data = weather, mapping = aes (x = temp)) +
  geom_histogram(bins = 40, color = "white")
```
Option 2
Using the second method, instead of specifying the number of bins, we specify the width of the bins by using the binwidth argument in the geom_histogram() layer. For example, let’s set the width of each bin to be 10°F.
```{r}
ggplot(data = weather, mapping = aes(x = temp)) +
geom_histogram(binwidth = 10, color = "white")
```
# Facets
Faceting is used when we’d like to split a particular visualization by the values of another variable.
This will create multiple copies of the same type of plot with matching x and y axes, but whose content will differ.

For example, suppose we were interested in looking at how the histogram of hourly temperature recordings at the three NYC airports we saw in Figure 2.9 differed in each month. We could “split” this histogram by the 12 possible months in a given year. In other words, we would plot histograms of temp for each month separately. We do this by adding facet_wrap(~ month) layer. Note the ~ is a “tilde” and can generally be found on the key next to the “1” key on US keyboards. The tilde is required and you’ll receive the error Error in as.quoted(facets) : object 'month' not found if you don’t include it here.
```{r}
ggplot(data = weather, mapping = aes(x = temp)) +
  geom_histogram(binwidth = 5, color = "white") +
  facet_wrap(~ month)
```
We can also specify the number of rows and columns in the grid by using the nrow and ncol arguments inside of facet_wrap(). For example, say we would like our faceted histogram to have 4 rows instead of 3. We simply add an nrow = 4 argument to facet_wrap(~ month).

```{r}
ggplot(data = weather, mapping = aes(x = temp)) +
  geom_histogram(binwidth = 5, color = "white") +
  facet_wrap(~ month, nrow = 4)
```

# Boxplots
While faceted histograms are one type of visualization used to compare the distribution of a numerical variable split by the values of another variable, another type of visualization that achieves this same goal is a side-by-side boxplot.

Let’s now create a side-by-side boxplot of hourly temperatures split by the 12 months as we did previously with the faceted histograms. We do this by mapping the month variable to the x-position aesthetic, the temp variable to the y-position aesthetic, and by adding a geom_boxplot() layer:

```{r}
ggplot(data = weather, mapping = aes(x = month, y = temp)) +
  geom_boxplot()
```
The first warning message clues us in as to why. It is telling us that we have a “continuous”, or numerical variable, on the x-position aesthetic. Boxplots, however, require a categorical variable to be mapped to the x-position aesthetic.

**We can convert the numerical variable month into a factor categorical variable by using the factor() function.** So after applying factor(month), month goes from having numerical values just the 1, 2, …, and 12 to having an associated ordering. With this ordering, ggplot() now knows how to work with this variable to produce the needed plot.

```{r}
ggplot(data = weather, mapping = aes(x = factor(month), y = temp)) +
  geom_boxplot()
```
Side-by-side boxplots provide us with a way to compare the distribution of a numerical variable across multiple values of another variable. One can see where the median falls across the different groups by comparing the solid lines in the center of the boxes.

To study the spread of a numerical variable within one of the boxes, look at both the length of the box and also how far the whiskers extend from either end of the box. Outliers are even more easily identified when looking at a boxplot than when looking at a histogram as they are marked with distinct points.

# Barplots

Both histograms and boxplots are tools to visualize the distribution of numerical variables. Another commonly desired task is to visualize the distribution of a categorical variable. This is a simpler task, as we are simply counting different categories within a categorical variable, also known as the levels of the categorical variable. Often the best way to visualize these different counts, also known as frequencies, is with barplots (also called barcharts).

One complication, however, is how your data is represented. Is the categorical variable of interest “pre-counted” or not? For example, run the following code that manually creates two data frames representing a collection of fruit: 3 apples and 2 oranges.

```{r}
fruits <- tibble(
  fruit = c("apple", "apple", "orange", "apple", "orange")
)
fruits_counted <- tibble(
  fruit = c("apple", "orange"),
  number = c(3, 2)
)
```

Both the fruits and fruits_counted data frames represent the same collection of fruit. Whereas fruits just lists the fruit individually…

… fruits_counted has a variable count which represent the “pre-counted” values of each fruit.

```{r}
ggplot(data = fruits, mapping = aes(x = fruit)) +
  geom_bar()
```
```{r}
ggplot(data = fruits_counted, mapping = aes(x = fruit, y = number)) +
  geom_col()
```
Compare the barplots in Figures 2.19 and 2.20. They are identical because they reflect counts of the same five fruits. However, depending on how our categorical data is represented, either “pre-counted” or not, we must add a different geom layer. When the categorical variable whose distribution you want to visualize

- Is not pre-counted in your data frame, we use geom_bar().
- Is pre-counted in your data frame, we use geom_col() with the y-position aesthetic mapped to the variable that has the counts.

```{r}
ggplot(data = flights, mapping = aes(x = carrier)) +
  geom_bar()
```
# Two categorical variables

Barplots are a very common way to visualize the frequency of different categories, or levels, of a single categorical variable. Another use of barplots is to visualize the joint distribution of two categorical variables at the same time

We can now map the additional variable origin by adding a fill = origin inside the aes() aesthetic mapping.
**This is an example of a stacked barplot**
```{r}
ggplot(data = flights, mapping = aes(x = carrier, fill = origin)) +
  geom_bar()
```
## Common confusion for R new users
 First, the fill aesthetic corresponds to the color used to fill the bars, while the color aesthetic corresponds to the color of the outline of the bars.

```{r}
ggplot(data = flights, mapping = aes(x = carrier, color = origin)) +
  geom_bar()
```
Mapping origin to color and not fill yields grey bars with different colored outlines.

Second, note that fill is another aesthetic mapping much like x-position; thus we were careful to include it within the parentheses of the aes() mapping. The following code, where the fill aesthetic is specified outside the aes() mapping will yield an error. This is a fairly common error that new ggplot users make:

An alternative to stacked barplots are side-by-side barplots, also known as dodged barplots, The code to create a side-by-side barplot is identical to the code to create a stacked barplot, but with a **position = "dodge"** argument added to geom_bar(). In other words, we are overriding the default barplot type, which is a stacked barplot, and specifying it to be a side-by-side barplot instead.
```{r}
ggplot(data = flights, mapping = aes(x = carrier, fill = origin)) +
  geom_bar(position = "dodge")
```
Note the width of the bars for AS, F9, FL, HA and YV is different than the others. We can make one tweak to the position argument to get them to be the same size in terms of width as the other bars by using the more robust position_dodge() function.
```{r}
ggplot(data = flights, mapping = aes(x = carrier, fill = origin)) +
  geom_bar(position = position_dodge(preserve = "single"))
```
Lastly, another type of barplot is a **faceted barplot.** Recall in Section 2.6 we visualized the distribution of hourly temperatures at the 3 NYC airports split by month using facets. We apply the same principle to our barplot visualizing the frequency of carrier split by origin: instead of mapping origin to fill we include it as the variable to create small multiples of the plot across the levels of origin.

```{r}
ggplot(data = flights, mapping = aes(x = carrier)) +
  geom_bar() +
  facet_wrap(~origin, ncol = 1)
```


